<!doctype html>
<html>
<head>
	<title>Operating System</a>></title>
	<meta charset="utf-8">
</head>
<body>
	<h1><a href = "1.html">Operating System</a></h1>
	<ol>
		<li><a href = "2.html">Memory</a></li>
		<li><a href = "3.html">File System</a></li>
		<li><a href = "4.html">Interrupt</a></li>
	</ol>
	<h2>Interrupt</h2>
	마이크로프로세서에서 인터럽트(interrupt, 문화어: 중단, 새치기)란 마이크로프로세서(CPU)가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말한다.[1][2][3]

폴링이 대상을 주기적으로 감시하여 상황이 발생하면 해당처리 루틴을 실행해 처리한다면, 인터럽트는 상대가 마이크로프로세서에게 일을 처리해 달라고 요청하는 수단이다. 따라서 폴링과 대비되는 개념이다.[4][5] 폴링은 주기적으로 마이크로프로세서가 상태를 파악하기 위해 장치의 레지스터를 읽어야 한다. 이 작업이 진행되는 동안은 다른 장치는 체크가 힘들다. 그리고 이런 작업은 장치의 상태를 읽는데 마이크로프로세서의 자원이 낭비된다.[6]

마이크로프로세서의 다른일과 겹쳐 폴링이 고속의 하드웨어에서 데이터 손실될 여지가 있다면, 인터럽트는 해당 하드웨어가 CPU에게 요청하므로 빨리만 처리된다면 데이터 손실 위험이 작아진다. 폴링은 리얼타임에 문제의 소지가 있다면, 인터럽트는 필요할 때 처리되는 경향이 있어서 폴링보다 유리하다.

마이크로프로세서는 인터럽트를 감지하면 지금 실행중인 기계어 코드를 중단하고 해당 인터럽트를 위한 처리 프로그램으로 점프하여 해당 일을 수행 한다. 인터럽트 처리를 위한 루틴을 인터럽트 서비스 루틴(ISR, Interrupt Service Routine)이라고 한다. 인터럽트는 주로 하드웨어적으로 CPU 코어(CPU-core)에 입력되고, 현재 진행중인 기계어 코드가 종료되면 실행한다. 인터럽트가 접수 되었을 때, 인터럽트를 처리할 것인가는 CPU코어의 특수레지스터에 비트 마스크를 통해 선택적으로 수용한다.[1][2][3]

인터럽트가 걸리면 해당 서비스 루틴이 실행되어야 하는데, 현재 진행중인 프로그램이 영향을 받으면 안되므로 우선 ISR에서 레지스터를 스택에 대피하고 해당일을 수행한다. 레지스터 대피는 ISR에서 행하도록 기계어 코드를 구성해야 한다. C로 작성할 경우 일반함수와 차이를 두어 컴파일마다 정의하는 방식이 제공된다.[7]

CPU코어 외부에서 인터럽트를 거는 경우가 일반적이지만, CPU 내부에서 실행하면서 걸리는 경우도 있다. 예를 들어 DIV 명령어를 실행할 때 0으로 나누어지거나, 주소 버스에서 할당되지 않는 주소공간을 액세스 한다든지 하는 경우를 예외(exception)라고 말하고 예외처리를 한다.[1] 인터럽트는 예외처리의 한 종류로 예외처리의 방식에 의해 처리된다.

인터럽트를 소프트웨어적으로 실행하는 방법도 제공한다. 인터럽트 기계어 명령에 의해 실행된다. x86의 경우 INT 명령어가 소프트웨어 인터럽트 명령어 이다. 리눅스 커널과 같은 운영 체제에서 응용 프로그램의 저수준 입출력 함수가 실행되면, 해당 실시간 라이브러리 함수에 의해 소프트웨어 인터럽트가 실행된다. 이것을 시스템 콜(system call)이라고 하고, 함수의 기능에 따라 드라이버를 구별하고 드라이버 내의 함수를 지정함과 동시에 데이터를 레지스터를 통해 넘겨준다.

어떤 마이크로프로세서(모토로라 68000)의 경우 트랩이라는 용어를 사용하기도 한다.[1]

컴퓨터 시스템에서 인터럽트를 거는 원천은 여러개가 존재하는 것이 일반적이다. 따라서 인터럽트의 종류를 구분하는 방법이 필요하다.
</body>
</html>